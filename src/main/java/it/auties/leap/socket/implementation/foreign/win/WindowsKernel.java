// Generated by jextract

package it.auties.leap.socket.implementation.foreign.win;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.util.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;

public class WindowsKernel {

    WindowsKernel() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();
    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean("jextract.trace.downcalls");

    static void traceDowncall(String name, Object... args) {
         String traceArgs = Arrays.stream(args)
                       .map(Object::toString)
                       .collect(Collectors.joining(", "));
         System.out.printf("%s(%s)\n", name, traceArgs);
    }

    static MemorySegment findOrThrow(String symbol) {
        return SYMBOL_LOOKUP.find(symbol)
            .orElseThrow(() -> new UnsatisfiedLinkError("unresolved symbol: " + symbol));
    }

    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {
        try {
            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());
        } catch (ReflectiveOperationException ex) {
            throw new AssertionError(ex);
        }
    }

    static MemoryLayout align(MemoryLayout layout, long align) {
        return switch (layout) {
            case PaddingLayout p -> p;
            case ValueLayout v -> v.withByteAlignment(align);
            case GroupLayout g -> {
                MemoryLayout[] alignedMembers = g.memberLayouts().stream()
                        .map(m -> align(m, align)).toArray(MemoryLayout[]::new);
                yield g instanceof StructLayout ?
                        MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);
            }
            case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));
        };
    }

    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.loaderLookup()
            .or(Linker.nativeLinker().defaultLookup());

    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;
    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;
    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;
    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;
    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;
    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;
    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;
    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS
            .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, JAVA_BYTE));
    public static final ValueLayout.OfInt C_LONG = ValueLayout.JAVA_INT;
    public static final ValueLayout.OfDouble C_LONG_DOUBLE = ValueLayout.JAVA_DOUBLE;
    private static final int AF_INET = (int)2L;
    /**
     * {@snippet lang=c :
     * #define AF_INET 2
     * }
     */
    public static int AF_INET() {
        return AF_INET;
    }
    private static final int SOCK_STREAM = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SOCK_STREAM 1
     * }
     */
    public static int SOCK_STREAM() {
        return SOCK_STREAM;
    }
    private static final int SOL_SOCKET = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define SOL_SOCKET 65535
     * }
     */
    public static int SOL_SOCKET() {
        return SOL_SOCKET;
    }
    private static final int SO_KEEPALIVE = (int)8L;
    /**
     * {@snippet lang=c :
     * #define SO_KEEPALIVE 8
     * }
     */
    public static int SO_KEEPALIVE() {
        return SO_KEEPALIVE;
    }
    private static final int WSA_FLAG_OVERLAPPED = (int)1L;
    /**
     * {@snippet lang=c :
     * #define WSA_FLAG_OVERLAPPED 1
     * }
     */
    public static int WSA_FLAG_OVERLAPPED() {
        return WSA_FLAG_OVERLAPPED;
    }
    private static final int SO_UPDATE_CONNECT_CONTEXT = (int)28688L;
    /**
     * {@snippet lang=c :
     * #define SO_UPDATE_CONNECT_CONTEXT 28688
     * }
     */
    public static int SO_UPDATE_CONNECT_CONTEXT() {
        return SO_UPDATE_CONNECT_CONTEXT;
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned long ULONG
     * }
     */
    public static final OfInt ULONG = WindowsKernel.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long DWORD
     * }
     */
    public static final OfInt DWORD = WindowsKernel.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int BOOL
     * }
     */
    public static final OfInt BOOL = WindowsKernel.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short WORD
     * }
     */
    public static final OfShort WORD = WindowsKernel.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef DWORD *LPDWORD
     * }
     */
    public static final AddressLayout LPDWORD = WindowsKernel.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef void *PVOID
     * }
     */
    public static final AddressLayout PVOID = WindowsKernel.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef void *HANDLE
     * }
     */
    public static final AddressLayout HANDLE = WindowsKernel.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OVERLAPPED {
     *     ULONG_PTR Internal;
     *     ULONG_PTR InternalHigh;
     *     union {
     *         struct {
     *             DWORD Offset;
     *             DWORD OffsetHigh;
     *         };
     *         PVOID Pointer;
     *     };
     *     HANDLE hEvent;
     * } *LPOVERLAPPED
     * }
     */
    public static final AddressLayout LPOVERLAPPED = WindowsKernel.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OVERLAPPED_ENTRY {
     *     ULONG_PTR lpCompletionKey;
     *     LPOVERLAPPED lpOverlapped;
     *     ULONG_PTR Internal;
     *     DWORD dwNumberOfBytesTransferred;
     * } *LPOVERLAPPED_ENTRY
     * }
     */
    public static final AddressLayout LPOVERLAPPED_ENTRY = WindowsKernel.C_POINTER;

    private static class CloseHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WindowsKernel.C_INT,
            WindowsKernel.C_POINTER
        );

        public static final MemorySegment ADDR = WindowsKernel.findOrThrow("CloseHandle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CloseHandle(HANDLE hObject)
     * }
     */
    public static FunctionDescriptor CloseHandle$descriptor() {
        return CloseHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CloseHandle(HANDLE hObject)
     * }
     */
    public static MethodHandle CloseHandle$handle() {
        return CloseHandle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL CloseHandle(HANDLE hObject)
     * }
     */
    public static MemorySegment CloseHandle$address() {
        return CloseHandle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL CloseHandle(HANDLE hObject)
     * }
     */
    public static int CloseHandle(MemorySegment hObject) {
        var mh$ = CloseHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseHandle", hObject);
            }
            return (int)mh$.invokeExact(hObject);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLastError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WindowsKernel.C_LONG    );

        public static final MemorySegment ADDR = WindowsKernel.findOrThrow("GetLastError");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetLastError()
     * }
     */
    public static FunctionDescriptor GetLastError$descriptor() {
        return GetLastError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetLastError()
     * }
     */
    public static MethodHandle GetLastError$handle() {
        return GetLastError.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD GetLastError()
     * }
     */
    public static MemorySegment GetLastError$address() {
        return GetLastError.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD GetLastError()
     * }
     */
    public static int GetLastError() {
        var mh$ = GetLastError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLastError");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateIoCompletionPort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WindowsKernel.C_POINTER,
            WindowsKernel.C_POINTER,
            WindowsKernel.C_POINTER,
            WindowsKernel.C_LONG_LONG,
            WindowsKernel.C_LONG
        );

        public static final MemorySegment ADDR = WindowsKernel.findOrThrow("CreateIoCompletionPort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateIoCompletionPort(HANDLE FileHandle, HANDLE ExistingCompletionPort, ULONG_PTR CompletionKey, DWORD NumberOfConcurrentThreads)
     * }
     */
    public static FunctionDescriptor CreateIoCompletionPort$descriptor() {
        return CreateIoCompletionPort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateIoCompletionPort(HANDLE FileHandle, HANDLE ExistingCompletionPort, ULONG_PTR CompletionKey, DWORD NumberOfConcurrentThreads)
     * }
     */
    public static MethodHandle CreateIoCompletionPort$handle() {
        return CreateIoCompletionPort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * HANDLE CreateIoCompletionPort(HANDLE FileHandle, HANDLE ExistingCompletionPort, ULONG_PTR CompletionKey, DWORD NumberOfConcurrentThreads)
     * }
     */
    public static MemorySegment CreateIoCompletionPort$address() {
        return CreateIoCompletionPort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * HANDLE CreateIoCompletionPort(HANDLE FileHandle, HANDLE ExistingCompletionPort, ULONG_PTR CompletionKey, DWORD NumberOfConcurrentThreads)
     * }
     */
    public static MemorySegment CreateIoCompletionPort(MemorySegment FileHandle, MemorySegment ExistingCompletionPort, long CompletionKey, int NumberOfConcurrentThreads) {
        var mh$ = CreateIoCompletionPort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateIoCompletionPort", FileHandle, ExistingCompletionPort, CompletionKey, NumberOfConcurrentThreads);
            }
            return (MemorySegment)mh$.invokeExact(FileHandle, ExistingCompletionPort, CompletionKey, NumberOfConcurrentThreads);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetQueuedCompletionStatus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WindowsKernel.C_INT,
            WindowsKernel.C_POINTER,
            WindowsKernel.C_POINTER,
            WindowsKernel.C_POINTER,
            WindowsKernel.C_POINTER,
            WindowsKernel.C_LONG
        );

        public static final MemorySegment ADDR = WindowsKernel.findOrThrow("GetQueuedCompletionStatus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetQueuedCompletionStatus(HANDLE CompletionPort, LPDWORD lpNumberOfBytesTransferred, PULONG_PTR lpCompletionKey, LPOVERLAPPED *lpOverlapped, DWORD dwMilliseconds)
     * }
     */
    public static FunctionDescriptor GetQueuedCompletionStatus$descriptor() {
        return GetQueuedCompletionStatus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetQueuedCompletionStatus(HANDLE CompletionPort, LPDWORD lpNumberOfBytesTransferred, PULONG_PTR lpCompletionKey, LPOVERLAPPED *lpOverlapped, DWORD dwMilliseconds)
     * }
     */
    public static MethodHandle GetQueuedCompletionStatus$handle() {
        return GetQueuedCompletionStatus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetQueuedCompletionStatus(HANDLE CompletionPort, LPDWORD lpNumberOfBytesTransferred, PULONG_PTR lpCompletionKey, LPOVERLAPPED *lpOverlapped, DWORD dwMilliseconds)
     * }
     */
    public static MemorySegment GetQueuedCompletionStatus$address() {
        return GetQueuedCompletionStatus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetQueuedCompletionStatus(HANDLE CompletionPort, LPDWORD lpNumberOfBytesTransferred, PULONG_PTR lpCompletionKey, LPOVERLAPPED *lpOverlapped, DWORD dwMilliseconds)
     * }
     */
    public static int GetQueuedCompletionStatus(MemorySegment CompletionPort, MemorySegment lpNumberOfBytesTransferred, MemorySegment lpCompletionKey, MemorySegment lpOverlapped, int dwMilliseconds) {
        var mh$ = GetQueuedCompletionStatus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetQueuedCompletionStatus", CompletionPort, lpNumberOfBytesTransferred, lpCompletionKey, lpOverlapped, dwMilliseconds);
            }
            return (int)mh$.invokeExact(CompletionPort, lpNumberOfBytesTransferred, lpCompletionKey, lpOverlapped, dwMilliseconds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetQueuedCompletionStatusEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WindowsKernel.C_INT,
            WindowsKernel.C_POINTER,
            WindowsKernel.C_POINTER,
            WindowsKernel.C_LONG,
            WindowsKernel.C_POINTER,
            WindowsKernel.C_LONG,
            WindowsKernel.C_INT
        );

        public static final MemorySegment ADDR = WindowsKernel.findOrThrow("GetQueuedCompletionStatusEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetQueuedCompletionStatusEx(HANDLE CompletionPort, LPOVERLAPPED_ENTRY lpCompletionPortEntries, ULONG ulCount, PULONG ulNumEntriesRemoved, DWORD dwMilliseconds, BOOL fAlertable)
     * }
     */
    public static FunctionDescriptor GetQueuedCompletionStatusEx$descriptor() {
        return GetQueuedCompletionStatusEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetQueuedCompletionStatusEx(HANDLE CompletionPort, LPOVERLAPPED_ENTRY lpCompletionPortEntries, ULONG ulCount, PULONG ulNumEntriesRemoved, DWORD dwMilliseconds, BOOL fAlertable)
     * }
     */
    public static MethodHandle GetQueuedCompletionStatusEx$handle() {
        return GetQueuedCompletionStatusEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetQueuedCompletionStatusEx(HANDLE CompletionPort, LPOVERLAPPED_ENTRY lpCompletionPortEntries, ULONG ulCount, PULONG ulNumEntriesRemoved, DWORD dwMilliseconds, BOOL fAlertable)
     * }
     */
    public static MemorySegment GetQueuedCompletionStatusEx$address() {
        return GetQueuedCompletionStatusEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetQueuedCompletionStatusEx(HANDLE CompletionPort, LPOVERLAPPED_ENTRY lpCompletionPortEntries, ULONG ulCount, PULONG ulNumEntriesRemoved, DWORD dwMilliseconds, BOOL fAlertable)
     * }
     */
    public static int GetQueuedCompletionStatusEx(MemorySegment CompletionPort, MemorySegment lpCompletionPortEntries, int ulCount, MemorySegment ulNumEntriesRemoved, int dwMilliseconds, int fAlertable) {
        var mh$ = GetQueuedCompletionStatusEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetQueuedCompletionStatusEx", CompletionPort, lpCompletionPortEntries, ulCount, ulNumEntriesRemoved, dwMilliseconds, fAlertable);
            }
            return (int)mh$.invokeExact(CompletionPort, lpCompletionPortEntries, ulCount, ulNumEntriesRemoved, dwMilliseconds, fAlertable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetOverlappedResult {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WindowsKernel.C_INT,
            WindowsKernel.C_POINTER,
            WindowsKernel.C_POINTER,
            WindowsKernel.C_POINTER,
            WindowsKernel.C_INT
        );

        public static final MemorySegment ADDR = WindowsKernel.findOrThrow("GetOverlappedResult");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetOverlappedResult(HANDLE hFile, LPOVERLAPPED lpOverlapped, LPDWORD lpNumberOfBytesTransferred, BOOL bWait)
     * }
     */
    public static FunctionDescriptor GetOverlappedResult$descriptor() {
        return GetOverlappedResult.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetOverlappedResult(HANDLE hFile, LPOVERLAPPED lpOverlapped, LPDWORD lpNumberOfBytesTransferred, BOOL bWait)
     * }
     */
    public static MethodHandle GetOverlappedResult$handle() {
        return GetOverlappedResult.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BOOL GetOverlappedResult(HANDLE hFile, LPOVERLAPPED lpOverlapped, LPDWORD lpNumberOfBytesTransferred, BOOL bWait)
     * }
     */
    public static MemorySegment GetOverlappedResult$address() {
        return GetOverlappedResult.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BOOL GetOverlappedResult(HANDLE hFile, LPOVERLAPPED lpOverlapped, LPDWORD lpNumberOfBytesTransferred, BOOL bWait)
     * }
     */
    public static int GetOverlappedResult(MemorySegment hFile, MemorySegment lpOverlapped, MemorySegment lpNumberOfBytesTransferred, int bWait) {
        var mh$ = GetOverlappedResult.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetOverlappedResult", hFile, lpOverlapped, lpNumberOfBytesTransferred, bWait);
            }
            return (int)mh$.invokeExact(hFile, lpOverlapped, lpNumberOfBytesTransferred, bWait);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int IPPROTO_TCP = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_TCP = 6
     * }
     */
    public static int IPPROTO_TCP() {
        return IPPROTO_TCP;
    }
    /**
     * {@snippet lang=c :
     * typedef UINT_PTR SOCKET
     * }
     */
    public static final OfLong SOCKET = WindowsKernel.C_LONG_LONG;

    private static class bind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WindowsKernel.C_INT,
            WindowsKernel.C_LONG_LONG,
            WindowsKernel.C_POINTER,
            WindowsKernel.C_INT
        );

        public static final MemorySegment ADDR = WindowsKernel.findOrThrow("bind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int bind(SOCKET s, const struct sockaddr *name, int namelen)
     * }
     */
    public static FunctionDescriptor bind$descriptor() {
        return bind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int bind(SOCKET s, const struct sockaddr *name, int namelen)
     * }
     */
    public static MethodHandle bind$handle() {
        return bind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int bind(SOCKET s, const struct sockaddr *name, int namelen)
     * }
     */
    public static MemorySegment bind$address() {
        return bind.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int bind(SOCKET s, const struct sockaddr *name, int namelen)
     * }
     */
    public static int bind(long s, MemorySegment name, int namelen) {
        var mh$ = bind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bind", s, name, namelen);
            }
            return (int)mh$.invokeExact(s, name, namelen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class closesocket {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WindowsKernel.C_INT,
            WindowsKernel.C_LONG_LONG
        );

        public static final MemorySegment ADDR = WindowsKernel.findOrThrow("closesocket");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int closesocket(SOCKET s)
     * }
     */
    public static FunctionDescriptor closesocket$descriptor() {
        return closesocket.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int closesocket(SOCKET s)
     * }
     */
    public static MethodHandle closesocket$handle() {
        return closesocket.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int closesocket(SOCKET s)
     * }
     */
    public static MemorySegment closesocket$address() {
        return closesocket.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int closesocket(SOCKET s)
     * }
     */
    public static int closesocket(long s) {
        var mh$ = closesocket.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("closesocket", s);
            }
            return (int)mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class inet_addr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WindowsKernel.C_LONG,
            WindowsKernel.C_POINTER
        );

        public static final MemorySegment ADDR = WindowsKernel.findOrThrow("inet_addr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long inet_addr(const char *cp)
     * }
     */
    public static FunctionDescriptor inet_addr$descriptor() {
        return inet_addr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long inet_addr(const char *cp)
     * }
     */
    public static MethodHandle inet_addr$handle() {
        return inet_addr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long inet_addr(const char *cp)
     * }
     */
    public static MemorySegment inet_addr$address() {
        return inet_addr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long inet_addr(const char *cp)
     * }
     */
    public static int inet_addr(MemorySegment cp) {
        var mh$ = inet_addr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("inet_addr", cp);
            }
            return (int)mh$.invokeExact(cp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setsockopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WindowsKernel.C_INT,
            WindowsKernel.C_LONG_LONG,
            WindowsKernel.C_INT,
            WindowsKernel.C_INT,
            WindowsKernel.C_POINTER,
            WindowsKernel.C_INT
        );

        public static final MemorySegment ADDR = WindowsKernel.findOrThrow("setsockopt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setsockopt(SOCKET s, int level, int optname, const char *optval, int optlen)
     * }
     */
    public static FunctionDescriptor setsockopt$descriptor() {
        return setsockopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setsockopt(SOCKET s, int level, int optname, const char *optval, int optlen)
     * }
     */
    public static MethodHandle setsockopt$handle() {
        return setsockopt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setsockopt(SOCKET s, int level, int optname, const char *optval, int optlen)
     * }
     */
    public static MemorySegment setsockopt$address() {
        return setsockopt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setsockopt(SOCKET s, int level, int optname, const char *optval, int optlen)
     * }
     */
    public static int setsockopt(long s, int level, int optname, MemorySegment optval, int optlen) {
        var mh$ = setsockopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setsockopt", s, level, optname, optval, optlen);
            }
            return (int)mh$.invokeExact(s, level, optname, optval, optlen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class socket {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WindowsKernel.C_LONG_LONG,
            WindowsKernel.C_INT,
            WindowsKernel.C_INT,
            WindowsKernel.C_INT
        );

        public static final MemorySegment ADDR = WindowsKernel.findOrThrow("socket");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SOCKET socket(int af, int type, int protocol)
     * }
     */
    public static FunctionDescriptor socket$descriptor() {
        return socket.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SOCKET socket(int af, int type, int protocol)
     * }
     */
    public static MethodHandle socket$handle() {
        return socket.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SOCKET socket(int af, int type, int protocol)
     * }
     */
    public static MemorySegment socket$address() {
        return socket.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SOCKET socket(int af, int type, int protocol)
     * }
     */
    public static long socket(int af, int type, int protocol) {
        var mh$ = socket.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("socket", af, type, protocol);
            }
            return (long)mh$.invokeExact(af, type, protocol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WSAStartup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WindowsKernel.C_INT,
            WindowsKernel.C_SHORT,
            WindowsKernel.C_POINTER
        );

        public static final MemorySegment ADDR = WindowsKernel.findOrThrow("WSAStartup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData)
     * }
     */
    public static FunctionDescriptor WSAStartup$descriptor() {
        return WSAStartup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData)
     * }
     */
    public static MethodHandle WSAStartup$handle() {
        return WSAStartup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData)
     * }
     */
    public static MemorySegment WSAStartup$address() {
        return WSAStartup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData)
     * }
     */
    public static int WSAStartup(short wVersionRequested, MemorySegment lpWSAData) {
        var mh$ = WSAStartup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WSAStartup", wVersionRequested, lpWSAData);
            }
            return (int)mh$.invokeExact(wVersionRequested, lpWSAData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WSACleanup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WindowsKernel.C_INT    );

        public static final MemorySegment ADDR = WindowsKernel.findOrThrow("WSACleanup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int WSACleanup()
     * }
     */
    public static FunctionDescriptor WSACleanup$descriptor() {
        return WSACleanup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int WSACleanup()
     * }
     */
    public static MethodHandle WSACleanup$handle() {
        return WSACleanup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int WSACleanup()
     * }
     */
    public static MemorySegment WSACleanup$address() {
        return WSACleanup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int WSACleanup()
     * }
     */
    public static int WSACleanup() {
        var mh$ = WSACleanup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WSACleanup");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WSAGetLastError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WindowsKernel.C_INT    );

        public static final MemorySegment ADDR = WindowsKernel.findOrThrow("WSAGetLastError");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int WSAGetLastError()
     * }
     */
    public static FunctionDescriptor WSAGetLastError$descriptor() {
        return WSAGetLastError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int WSAGetLastError()
     * }
     */
    public static MethodHandle WSAGetLastError$handle() {
        return WSAGetLastError.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int WSAGetLastError()
     * }
     */
    public static MemorySegment WSAGetLastError$address() {
        return WSAGetLastError.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int WSAGetLastError()
     * }
     */
    public static int WSAGetLastError() {
        var mh$ = WSAGetLastError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WSAGetLastError");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WSAConnect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WindowsKernel.C_INT,
            WindowsKernel.C_LONG_LONG,
            WindowsKernel.C_POINTER,
            WindowsKernel.C_INT,
            WindowsKernel.C_POINTER,
            WindowsKernel.C_POINTER,
            WindowsKernel.C_POINTER,
            WindowsKernel.C_POINTER
        );

        public static final MemorySegment ADDR = WindowsKernel.findOrThrow("WSAConnect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int WSAConnect(SOCKET s, const struct sockaddr *name, int namelen, LPWSABUF lpCallerData, LPWSABUF lpCalleeData, LPQOS lpSQOS, LPQOS lpGQOS)
     * }
     */
    public static FunctionDescriptor WSAConnect$descriptor() {
        return WSAConnect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int WSAConnect(SOCKET s, const struct sockaddr *name, int namelen, LPWSABUF lpCallerData, LPWSABUF lpCalleeData, LPQOS lpSQOS, LPQOS lpGQOS)
     * }
     */
    public static MethodHandle WSAConnect$handle() {
        return WSAConnect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int WSAConnect(SOCKET s, const struct sockaddr *name, int namelen, LPWSABUF lpCallerData, LPWSABUF lpCalleeData, LPQOS lpSQOS, LPQOS lpGQOS)
     * }
     */
    public static MemorySegment WSAConnect$address() {
        return WSAConnect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int WSAConnect(SOCKET s, const struct sockaddr *name, int namelen, LPWSABUF lpCallerData, LPWSABUF lpCalleeData, LPQOS lpSQOS, LPQOS lpGQOS)
     * }
     */
    public static int WSAConnect(long s, MemorySegment name, int namelen, MemorySegment lpCallerData, MemorySegment lpCalleeData, MemorySegment lpSQOS, MemorySegment lpGQOS) {
        var mh$ = WSAConnect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WSAConnect", s, name, namelen, lpCallerData, lpCalleeData, lpSQOS, lpGQOS);
            }
            return (int)mh$.invokeExact(s, name, namelen, lpCallerData, lpCalleeData, lpSQOS, lpGQOS);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WSAIoctl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WindowsKernel.C_INT,
            WindowsKernel.C_LONG_LONG,
            WindowsKernel.C_LONG,
            WindowsKernel.C_POINTER,
            WindowsKernel.C_LONG,
            WindowsKernel.C_POINTER,
            WindowsKernel.C_LONG,
            WindowsKernel.C_POINTER,
            WindowsKernel.C_POINTER,
            WindowsKernel.C_POINTER
        );

        public static final MemorySegment ADDR = WindowsKernel.findOrThrow("WSAIoctl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int WSAIoctl(SOCKET s, DWORD dwIoControlCode, LPVOID lpvInBuffer, DWORD cbInBuffer, LPVOID lpvOutBuffer, DWORD cbOutBuffer, LPDWORD lpcbBytesReturned, LPWSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
     * }
     */
    public static FunctionDescriptor WSAIoctl$descriptor() {
        return WSAIoctl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int WSAIoctl(SOCKET s, DWORD dwIoControlCode, LPVOID lpvInBuffer, DWORD cbInBuffer, LPVOID lpvOutBuffer, DWORD cbOutBuffer, LPDWORD lpcbBytesReturned, LPWSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
     * }
     */
    public static MethodHandle WSAIoctl$handle() {
        return WSAIoctl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int WSAIoctl(SOCKET s, DWORD dwIoControlCode, LPVOID lpvInBuffer, DWORD cbInBuffer, LPVOID lpvOutBuffer, DWORD cbOutBuffer, LPDWORD lpcbBytesReturned, LPWSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
     * }
     */
    public static MemorySegment WSAIoctl$address() {
        return WSAIoctl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int WSAIoctl(SOCKET s, DWORD dwIoControlCode, LPVOID lpvInBuffer, DWORD cbInBuffer, LPVOID lpvOutBuffer, DWORD cbOutBuffer, LPDWORD lpcbBytesReturned, LPWSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
     * }
     */
    public static int WSAIoctl(long s, int dwIoControlCode, MemorySegment lpvInBuffer, int cbInBuffer, MemorySegment lpvOutBuffer, int cbOutBuffer, MemorySegment lpcbBytesReturned, MemorySegment lpOverlapped, MemorySegment lpCompletionRoutine) {
        var mh$ = WSAIoctl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WSAIoctl", s, dwIoControlCode, lpvInBuffer, cbInBuffer, lpvOutBuffer, cbOutBuffer, lpcbBytesReturned, lpOverlapped, lpCompletionRoutine);
            }
            return (int)mh$.invokeExact(s, dwIoControlCode, lpvInBuffer, cbInBuffer, lpvOutBuffer, cbOutBuffer, lpcbBytesReturned, lpOverlapped, lpCompletionRoutine);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WSARecv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WindowsKernel.C_INT,
            WindowsKernel.C_LONG_LONG,
            WindowsKernel.C_POINTER,
            WindowsKernel.C_LONG,
            WindowsKernel.C_POINTER,
            WindowsKernel.C_POINTER,
            WindowsKernel.C_POINTER,
            WindowsKernel.C_POINTER
        );

        public static final MemorySegment ADDR = WindowsKernel.findOrThrow("WSARecv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int WSARecv(SOCKET s, LPWSABUF lpBuffers, DWORD dwBufferCount, LPDWORD lpNumberOfBytesRecvd, LPDWORD lpFlags, LPWSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
     * }
     */
    public static FunctionDescriptor WSARecv$descriptor() {
        return WSARecv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int WSARecv(SOCKET s, LPWSABUF lpBuffers, DWORD dwBufferCount, LPDWORD lpNumberOfBytesRecvd, LPDWORD lpFlags, LPWSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
     * }
     */
    public static MethodHandle WSARecv$handle() {
        return WSARecv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int WSARecv(SOCKET s, LPWSABUF lpBuffers, DWORD dwBufferCount, LPDWORD lpNumberOfBytesRecvd, LPDWORD lpFlags, LPWSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
     * }
     */
    public static MemorySegment WSARecv$address() {
        return WSARecv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int WSARecv(SOCKET s, LPWSABUF lpBuffers, DWORD dwBufferCount, LPDWORD lpNumberOfBytesRecvd, LPDWORD lpFlags, LPWSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
     * }
     */
    public static int WSARecv(long s, MemorySegment lpBuffers, int dwBufferCount, MemorySegment lpNumberOfBytesRecvd, MemorySegment lpFlags, MemorySegment lpOverlapped, MemorySegment lpCompletionRoutine) {
        var mh$ = WSARecv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WSARecv", s, lpBuffers, dwBufferCount, lpNumberOfBytesRecvd, lpFlags, lpOverlapped, lpCompletionRoutine);
            }
            return (int)mh$.invokeExact(s, lpBuffers, dwBufferCount, lpNumberOfBytesRecvd, lpFlags, lpOverlapped, lpCompletionRoutine);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WSASend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WindowsKernel.C_INT,
            WindowsKernel.C_LONG_LONG,
            WindowsKernel.C_POINTER,
            WindowsKernel.C_LONG,
            WindowsKernel.C_POINTER,
            WindowsKernel.C_LONG,
            WindowsKernel.C_POINTER,
            WindowsKernel.C_POINTER
        );

        public static final MemorySegment ADDR = WindowsKernel.findOrThrow("WSASend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int WSASend(SOCKET s, LPWSABUF lpBuffers, DWORD dwBufferCount, LPDWORD lpNumberOfBytesSent, DWORD dwFlags, LPWSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
     * }
     */
    public static FunctionDescriptor WSASend$descriptor() {
        return WSASend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int WSASend(SOCKET s, LPWSABUF lpBuffers, DWORD dwBufferCount, LPDWORD lpNumberOfBytesSent, DWORD dwFlags, LPWSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
     * }
     */
    public static MethodHandle WSASend$handle() {
        return WSASend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int WSASend(SOCKET s, LPWSABUF lpBuffers, DWORD dwBufferCount, LPDWORD lpNumberOfBytesSent, DWORD dwFlags, LPWSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
     * }
     */
    public static MemorySegment WSASend$address() {
        return WSASend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int WSASend(SOCKET s, LPWSABUF lpBuffers, DWORD dwBufferCount, LPDWORD lpNumberOfBytesSent, DWORD dwFlags, LPWSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
     * }
     */
    public static int WSASend(long s, MemorySegment lpBuffers, int dwBufferCount, MemorySegment lpNumberOfBytesSent, int dwFlags, MemorySegment lpOverlapped, MemorySegment lpCompletionRoutine) {
        var mh$ = WSASend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WSASend", s, lpBuffers, dwBufferCount, lpNumberOfBytesSent, dwFlags, lpOverlapped, lpCompletionRoutine);
            }
            return (int)mh$.invokeExact(s, lpBuffers, dwBufferCount, lpNumberOfBytesSent, dwFlags, lpOverlapped, lpCompletionRoutine);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WSASocketA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WindowsKernel.C_LONG_LONG,
            WindowsKernel.C_INT,
            WindowsKernel.C_INT,
            WindowsKernel.C_INT,
            WindowsKernel.C_POINTER,
            WindowsKernel.C_INT,
            WindowsKernel.C_LONG
        );

        public static final MemorySegment ADDR = WindowsKernel.findOrThrow("WSASocketA");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SOCKET WSASocketA(int af, int type, int protocol, LPWSAPROTOCOL_INFOA lpProtocolInfo, GROUP g, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor WSASocketA$descriptor() {
        return WSASocketA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SOCKET WSASocketA(int af, int type, int protocol, LPWSAPROTOCOL_INFOA lpProtocolInfo, GROUP g, DWORD dwFlags)
     * }
     */
    public static MethodHandle WSASocketA$handle() {
        return WSASocketA.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SOCKET WSASocketA(int af, int type, int protocol, LPWSAPROTOCOL_INFOA lpProtocolInfo, GROUP g, DWORD dwFlags)
     * }
     */
    public static MemorySegment WSASocketA$address() {
        return WSASocketA.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SOCKET WSASocketA(int af, int type, int protocol, LPWSAPROTOCOL_INFOA lpProtocolInfo, GROUP g, DWORD dwFlags)
     * }
     */
    public static long WSASocketA(int af, int type, int protocol, MemorySegment lpProtocolInfo, int g, int dwFlags) {
        var mh$ = WSASocketA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WSASocketA", af, type, protocol, lpProtocolInfo, g, dwFlags);
            }
            return (long)mh$.invokeExact(af, type, protocol, lpProtocolInfo, g, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WSAWaitForMultipleEvents {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WindowsKernel.C_LONG,
            WindowsKernel.C_LONG,
            WindowsKernel.C_POINTER,
            WindowsKernel.C_INT,
            WindowsKernel.C_LONG,
            WindowsKernel.C_INT
        );

        public static final MemorySegment ADDR = WindowsKernel.findOrThrow("WSAWaitForMultipleEvents");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WSAWaitForMultipleEvents(DWORD cEvents, const HANDLE *lphEvents, BOOL fWaitAll, DWORD dwTimeout, BOOL fAlertable)
     * }
     */
    public static FunctionDescriptor WSAWaitForMultipleEvents$descriptor() {
        return WSAWaitForMultipleEvents.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WSAWaitForMultipleEvents(DWORD cEvents, const HANDLE *lphEvents, BOOL fWaitAll, DWORD dwTimeout, BOOL fAlertable)
     * }
     */
    public static MethodHandle WSAWaitForMultipleEvents$handle() {
        return WSAWaitForMultipleEvents.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * DWORD WSAWaitForMultipleEvents(DWORD cEvents, const HANDLE *lphEvents, BOOL fWaitAll, DWORD dwTimeout, BOOL fAlertable)
     * }
     */
    public static MemorySegment WSAWaitForMultipleEvents$address() {
        return WSAWaitForMultipleEvents.ADDR;
    }

    /**
     * {@snippet lang=c :
     * DWORD WSAWaitForMultipleEvents(DWORD cEvents, const HANDLE *lphEvents, BOOL fWaitAll, DWORD dwTimeout, BOOL fAlertable)
     * }
     */
    public static int WSAWaitForMultipleEvents(int cEvents, MemorySegment lphEvents, int fWaitAll, int dwTimeout, int fAlertable) {
        var mh$ = WSAWaitForMultipleEvents.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WSAWaitForMultipleEvents", cEvents, lphEvents, fWaitAll, dwTimeout, fAlertable);
            }
            return (int)mh$.invokeExact(cEvents, lphEvents, fWaitAll, dwTimeout, fAlertable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int INFINITE = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define INFINITE 4294967295
     * }
     */
    public static int INFINITE() {
        return INFINITE;
    }
    private static final int SIO_GET_EXTENSION_FUNCTION_POINTER = (int)3355443206L;
    /**
     * {@snippet lang=c :
     * #define SIO_GET_EXTENSION_FUNCTION_POINTER 3355443206
     * }
     */
    public static int SIO_GET_EXTENSION_FUNCTION_POINTER() {
        return SIO_GET_EXTENSION_FUNCTION_POINTER;
    }
    private static final int INADDR_ANY = (int)0L;
    /**
     * {@snippet lang=c :
     * #define INADDR_ANY 0
     * }
     */
    public static int INADDR_ANY() {
        return INADDR_ANY;
    }
    private static final int INADDR_NONE = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define INADDR_NONE 4294967295
     * }
     */
    public static int INADDR_NONE() {
        return INADDR_NONE;
    }
    private static final long INVALID_SOCKET = -1L;
    /**
     * {@snippet lang=c :
     * #define INVALID_SOCKET -1
     * }
     */
    public static long INVALID_SOCKET() {
        return INVALID_SOCKET;
    }
    private static final int SOCKET_ERROR = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define SOCKET_ERROR -1
     * }
     */
    public static int SOCKET_ERROR() {
        return SOCKET_ERROR;
    }
    private static final int WSA_IO_PENDING = (int)997L;
    /**
     * {@snippet lang=c :
     * #define WSA_IO_PENDING 997
     * }
     */
    public static int WSA_IO_PENDING() {
        return WSA_IO_PENDING;
    }
}

