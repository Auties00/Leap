package it.auties.leap.tls.ciphersuite.exchange.implementation;

import it.auties.leap.tls.alert.TlsAlert;
import it.auties.leap.tls.alert.TlsAlertLevel;
import it.auties.leap.tls.alert.TlsAlertType;
import it.auties.leap.tls.certificate.TlsCertificate;
import it.auties.leap.tls.ciphersuite.exchange.TlsKeyExchange;
import it.auties.leap.tls.ciphersuite.exchange.TlsKeyExchangeFactory;
import it.auties.leap.tls.ciphersuite.exchange.TlsKeyExchangeType;
import it.auties.leap.tls.connection.TlsConnection;
import it.auties.leap.tls.connection.TlsConnectionSecret;
import it.auties.leap.tls.context.TlsContext;
import it.auties.leap.tls.context.TlsContextualProperty;
import it.auties.leap.tls.group.TlsSupportedFiniteField;
import it.auties.leap.tls.group.TlsSupportedGroupKeys;

import javax.crypto.interfaces.DHPublicKey;
import java.math.BigInteger;
import java.nio.ByteBuffer;
import java.util.Optional;

import static it.auties.leap.tls.util.BufferUtils.*;

public abstract sealed class DHKeyExchange implements TlsKeyExchange {
    private static final TlsKeyExchangeFactory STATIC = new DHKeyExchangeFactory(TlsKeyExchangeType.STATIC);
    private static final TlsKeyExchangeFactory EPHEMERAL = new DHKeyExchangeFactory(TlsKeyExchangeType.EPHEMERAL);

    public static TlsKeyExchangeFactory staticFactory() {
        return STATIC;
    }

    public static TlsKeyExchangeFactory ephemeralFactory() {
        return EPHEMERAL;
    }

    final TlsKeyExchangeType type;
    private DHKeyExchange(TlsKeyExchangeType type) {
        this.type = type;
    }

    @Override
    public TlsKeyExchangeType type() {
        return type;
    }

    @Override
    public TlsConnectionSecret generatePreSharedSecret(TlsContext context) {
        var group = context.localConnectionState()
                .ephemeralKeyPair()
                .orElseThrow(() -> new TlsAlert(
                        "Cannot generate pre shared secret: no ephemeral key pair was selected",
                        TlsAlertLevel.FATAL,
                        TlsAlertType.HANDSHAKE_FAILURE
                ))
                .group();
        if(!(group instanceof TlsSupportedFiniteField)) {
            throw new TlsAlert(
                    "Cannot generate pre shared secret: selected ephemeral key pair was generated by a group that isn't a finite field",
                    TlsAlertLevel.FATAL,
                    TlsAlertType.HANDSHAKE_FAILURE
            );
        }
        return group.computeSharedSecret(context);
    }

    private static final class Client extends DHKeyExchange {
        private final byte[] publicKey;

        private Client(TlsKeyExchangeType type, byte[] publicKey) {
            super(type);
            this.publicKey = publicKey;
        }

        @Override
        public void serialize(ByteBuffer buffer) {
            writeBytesBigEndian16(buffer, publicKey);
        }

        @Override
        public int length() {
            return INT16_LENGTH + publicKey.length;
        }
    }

    private static final class Server extends DHKeyExchange {
        private final BigInteger p;
        private final BigInteger g;
        private final byte[] publicKey;

        private Server(TlsKeyExchangeType type, BigInteger p, BigInteger g, byte[] publicKey) {
            super(type);
            this.p = p;
            this.g = g;
            this.publicKey = publicKey;
        }

        @Override
        public void serialize(ByteBuffer buffer) {
            writeBytesBigEndian16(buffer, p.toByteArray());
            writeBytesBigEndian16(buffer, g.toByteArray());
            writeBytesBigEndian16(buffer, publicKey);
        }

        @Override
        public int length() {
            return INT16_LENGTH + (p.bitLength() + 8) / 8
                    + INT16_LENGTH + (g.bitLength() + 8) / 8
                    + INT16_LENGTH + publicKey.length;
        }
    }

    private record DHKeyExchangeFactory(TlsKeyExchangeType type) implements TlsKeyExchangeFactory {
        @Override
        public Optional<TlsKeyExchange> newLocalKeyExchange(TlsContext context) {
            var connectionState = context.localConnectionState();
            return switch (type) {
                case STATIC -> {
                    var certificate = getStaticCertificate(connectionState).orElseThrow(() -> new TlsAlert(
                            "Cannot generate static key exchange: no local DH key was provided",
                            TlsAlertLevel.FATAL,
                            TlsAlertType.HANDSHAKE_FAILURE
                    ));
                    var result = connectionState.chooseStaticCertificate(certificate);
                    if(!result) {
                        throw new TlsAlert(
                                "Cannot generate static key exchange: selected DH certificate doesn't exist",
                                TlsAlertLevel.FATAL,
                                TlsAlertType.HANDSHAKE_FAILURE
                        );
                    }
                    yield Optional.empty();
                }

                case EPHEMERAL -> switch (connectionState.type()) {
                    case CLIENT -> {
                        var remoteKeyExchange = context.remoteConnectionState()
                                .orElseThrow(() -> new TlsAlert(
                                        "Cannot generate ephemeral client key exchange: no remote server connection state was created",
                                        TlsAlertLevel.FATAL,
                                        TlsAlertType.HANDSHAKE_FAILURE
                                ))
                                .keyExchange()
                                .orElseThrow(() -> new TlsAlert(
                                        "Cannot generate ephemeral client key exchange: no remote server key exchange was created",
                                        TlsAlertLevel.FATAL,
                                        TlsAlertType.HANDSHAKE_FAILURE
                                ));
                        if(!(remoteKeyExchange instanceof Server remoteDhKeyExchange)) {
                            throw new TlsAlert(
                                    "Cannot generate ephemeral client key exchange: remote key exchange isn't a server DH key exchange",
                                    TlsAlertLevel.FATAL,
                                    TlsAlertType.HANDSHAKE_FAILURE
                            );
                        }
                        var negotiatedGroup = context.getNegotiatedValue(TlsContextualProperty.supportedGroups())
                                .orElseThrow(() -> new TlsAlert(
                                        "Cannot generate ephemeral client key exchange: no supported groups were negotiated",
                                        TlsAlertLevel.FATAL,
                                        TlsAlertType.HANDSHAKE_FAILURE
                                ))
                                .stream()
                                .filter(entry -> entry instanceof TlsSupportedFiniteField supportedFiniteField
                                        && supportedFiniteField.accepts(remoteDhKeyExchange.p, remoteDhKeyExchange.g))
                                .findFirst()
                                .orElseThrow(() -> new TlsAlert(
                                        "Cannot generate ephemeral client key exchange: no negotiated supported group that is a finite field accepts the server key exchange",
                                        TlsAlertLevel.FATAL,
                                        TlsAlertType.HANDSHAKE_FAILURE
                                ));
                        var keyPair = negotiatedGroup.generateKeyPair(context);
                        var publicKey = (DHPublicKey) keyPair.getPublic();
                        var result = connectionState.addEphemeralKeyPair(TlsSupportedGroupKeys.of(negotiatedGroup, keyPair))
                                .chooseEphemeralKeyPair(negotiatedGroup);
                        if(!result) {
                            throw new TlsAlert(
                                    "Cannot generate ephemeral client key exchange: selected ephemeral DH key pair doesn't exist",
                                    TlsAlertLevel.FATAL,
                                    TlsAlertType.HANDSHAKE_FAILURE
                            );
                        }
                        var localKeyExchange = new Client(type, publicKey.getY().toByteArray());
                        yield Optional.of(localKeyExchange);
                    }
                    case SERVER -> {
                        var preferredGroup = context.getNegotiatedValue(TlsContextualProperty.supportedGroups())
                                .orElseThrow(() -> new TlsAlert(
                                        "Cannot generate ephemeral server key exchange: no supported groups were negotiated",
                                        TlsAlertLevel.FATAL,
                                        TlsAlertType.HANDSHAKE_FAILURE
                                ))
                                .stream()
                                .filter(entry -> entry instanceof TlsSupportedFiniteField)
                                .findFirst()
                                .orElseThrow(() -> new TlsAlert(
                                        "Cannot generate ephemeral server key exchange: no negotiated supported group is a finite field",
                                        TlsAlertLevel.FATAL,
                                        TlsAlertType.HANDSHAKE_FAILURE
                                ));
                        var keyPair = preferredGroup.generateKeyPair(context);
                        var publicKey = (DHPublicKey) keyPair.getPublic();
                        var result = connectionState.addEphemeralKeyPair(TlsSupportedGroupKeys.of(preferredGroup, keyPair))
                                .chooseEphemeralKeyPair(preferredGroup);
                        if(!result) {
                            throw new TlsAlert(
                                    "Cannot generate ephemeral server key exchange: selected ephemeral DH key pair doesn't exist",
                                    TlsAlertLevel.FATAL,
                                    TlsAlertType.HANDSHAKE_FAILURE
                            );
                        }
                        var localKeyExchange = new Server(type, publicKey.getParams().getP(), publicKey.getParams().getG(), publicKey.getY().toByteArray());
                        yield Optional.of(localKeyExchange);
                    }
                };
            };
        }

        @Override
        public Optional<TlsKeyExchange> newRemoteKeyExchange(TlsContext context, ByteBuffer source) {
            return switch (type) {
                case STATIC -> {
                    if(source != null) {
                        throw new TlsAlert(
                                "Cannot generate static key exchange: received unexpected key exchange source",
                                TlsAlertLevel.FATAL,
                                TlsAlertType.INTERNAL_ERROR
                        );
                    }

                    var connectionState = context.remoteConnectionState().orElseThrow(() -> new TlsAlert(
                            "Cannot generate static key exchange: no remote server connection state was created",
                            TlsAlertLevel.FATAL,
                            TlsAlertType.HANDSHAKE_FAILURE
                    ));
                    var certificate = getStaticCertificate(connectionState).orElseThrow(() -> new TlsAlert(
                            "Cannot generate static key exchange: no remote DH key was received",
                            TlsAlertLevel.FATAL,
                            TlsAlertType.HANDSHAKE_FAILURE
                    ));
                    var result = connectionState.chooseStaticCertificate(certificate);
                    if(!result) {
                        throw new TlsAlert(
                                "Cannot generate static key exchange: selected DH certificate doesn't exist",
                                TlsAlertLevel.FATAL,
                                TlsAlertType.HANDSHAKE_FAILURE
                        );
                    }
                    yield Optional.empty();
                }

                case EPHEMERAL -> {
                    if(source == null) {
                        throw new TlsAlert(
                                "Cannot generate ephemeral key exchange: received null key exchange source",
                                TlsAlertLevel.FATAL,
                                TlsAlertType.INTERNAL_ERROR
                        );
                    }

                    var connectionState = context.remoteConnectionState().orElseThrow(() -> new TlsAlert(
                            "Cannot generate ephemeral key exchange: no remote server connection state was created",
                            TlsAlertLevel.FATAL,
                            TlsAlertType.HANDSHAKE_FAILURE
                    ));
                    yield switch (connectionState.type()) {
                        case CLIENT -> {
                            var y = readBytesBigEndian16(source);
                            var preferredGroup = context.getNegotiatedValue(TlsContextualProperty.supportedGroups())
                                    .orElseThrow(() -> new TlsAlert(
                                            "Cannot generate ephemeral client key exchange: no supported groups were negotiated",
                                            TlsAlertLevel.FATAL,
                                            TlsAlertType.HANDSHAKE_FAILURE
                                    ))
                                    .stream()
                                    .filter(entry -> entry instanceof TlsSupportedFiniteField)
                                    .findFirst()
                                    .orElseThrow(() -> new TlsAlert(
                                            "Cannot generate ephemeral client key exchange: no negotiated supported group is a finite field",
                                            TlsAlertLevel.FATAL,
                                            TlsAlertType.HANDSHAKE_FAILURE
                                    ));
                            var publicKey = preferredGroup.parsePublicKey(y);
                            var keys = TlsSupportedGroupKeys.of(preferredGroup, publicKey);
                            var result = connectionState.addEphemeralKeyPair(keys)
                                    .chooseEphemeralKeyPair(preferredGroup);
                            if(!result) {
                                throw new TlsAlert(
                                        "Cannot generate ephemeral client key exchange: selected ephemeral DH key pair doesn't exist",
                                        TlsAlertLevel.FATAL,
                                        TlsAlertType.HANDSHAKE_FAILURE
                                );
                            }
                            var remoteKeyExchange = new Client(type, y);
                            yield Optional.of(remoteKeyExchange);
                        }

                        case SERVER -> {
                            var p = new BigInteger(1, readBytesBigEndian16(source));
                            var g = new BigInteger(1, readBytesBigEndian16(source));
                            var y = readBytesBigEndian16(source);
                            var negotiatedGroup = context.getNegotiatedValue(TlsContextualProperty.supportedGroups())
                                    .orElseThrow(() -> new TlsAlert(
                                            "Cannot generate ephemeral server key exchange: no supported groups were negotiated",
                                            TlsAlertLevel.FATAL,
                                            TlsAlertType.HANDSHAKE_FAILURE
                                    ))
                                    .stream()
                                    .filter(entry -> entry instanceof TlsSupportedFiniteField supportedFiniteField
                                            && supportedFiniteField.accepts(p, g))
                                    .findFirst()
                                    .orElseThrow(() -> new TlsAlert(
                                            "Cannot generate ephemeral server key exchange: no negotiated supported group that is a finite field accepts the server key exchange",
                                            TlsAlertLevel.FATAL,
                                            TlsAlertType.HANDSHAKE_FAILURE
                                    ));
                            var publicKey = negotiatedGroup.parsePublicKey(y);
                            var keys = TlsSupportedGroupKeys.of(negotiatedGroup, publicKey);
                            var result = connectionState.addEphemeralKeyPair(keys)
                                    .chooseEphemeralKeyPair(negotiatedGroup);
                            if(!result) {
                                throw new TlsAlert(
                                        "Cannot generate ephemeral server key exchange: selected ephemeral DH key pair doesn't exist",
                                        TlsAlertLevel.FATAL,
                                        TlsAlertType.HANDSHAKE_FAILURE
                                );
                            }
                            var remoteKeyExchange = new Server(type, p, g, y);
                            yield Optional.of(remoteKeyExchange);
                        }
                    };
                }
            };
        }

        private Optional<TlsCertificate> getStaticCertificate(TlsConnection connectionState) {
            return connectionState.certificates()
                    .stream()
                    .filter(certificate -> certificate.publicKey() instanceof DHPublicKey)
                    .findFirst();
        }
    }
}
